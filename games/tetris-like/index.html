<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover, user-scalable=no" />
  <title>ブロック落とし – Nihatori Games</title>
  <link rel="stylesheet" href="/styles.css" />
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    html, body { height: 100%; overflow: hidden; touch-action: none; -webkit-tap-highlight-color: transparent; }
    body.game-page {
      padding-top: 48px;
      background: linear-gradient(180deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
      font-family: "MS PGothic", "Yu Gothic", sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
      color: #e8e8e8;
    }
    .tet-wrap {
      flex: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      width: 100%;
      max-width: 360px;
      padding: 8px;
      min-height: 0;
    }
    .tet-title { font-size: 1rem; font-weight: bold; margin-bottom: 4px; flex-shrink: 0; }
    .tet-hud {
      display: flex;
      justify-content: space-between;
      align-items: center;
      width: 100%;
      margin-bottom: 4px;
      font-size: 14px;
      flex-shrink: 0;
    }
    .tet-plate-info { font-size: 12px; color: #778da9; }
    .tet-main {
      flex: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 0;
      width: 100%;
    }
    .tet-canvas-wrap {
      flex: 1;
      width: 100%;
      min-height: 200px;
      background: #0d1b2a;
      border-radius: 8px;
      overflow: hidden;
      box-shadow: 0 4px 20px rgba(0,0,0,0.5);
      border: 2px solid #415a77;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    #tetCanvas {
      display: block;
      width: 100%;
      height: 100%;
      object-fit: contain;
    }
    .tet-howto {
      font-size: 11px;
      color: #778da9;
      margin-top: 8px;
      text-align: center;
    }
    .tet-overlay {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.7);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 20;
      padding: 48px 16px 0;
    }
    .tet-overlay.visible { display: flex; }
    .tet-overlay-box {
      background: linear-gradient(180deg, #1b263b 0%, #0d1b2a 100%);
      border-radius: 16px;
      padding: 24px;
      text-align: center;
      max-width: 320px;
      border: 2px solid #415a77;
      box-shadow: 0 8px 32px rgba(0,0,0,0.5);
      color: #e0e1dd;
    }
    .tet-overlay-box h2 { margin-bottom: 12px; font-size: 1.35rem; color: #e0e1dd; }
    .tet-overlay-box p { margin-bottom: 16px; color: #778da9; font-size: 14px; }
    .tet-overlay-box .btn {
      display: inline-block;
      padding: 12px 28px;
      background: linear-gradient(180deg, #e63946, #c1121f);
      color: #fff;
      border: none;
      border-radius: 10px;
      font-size: 1rem;
      font-weight: bold;
      cursor: pointer;
      text-decoration: none;
      -webkit-tap-highlight-color: transparent;
    }
    .tet-back { display: inline-block; margin-top: 12px; color: #778da9; font-size: 14px; text-decoration: none; }
    .tet-back:hover { text-decoration: underline; color: #e0e1dd; }
  </style>
</head>
<body class="game-page">
  <div id="site-header"></div>

  <div class="tet-wrap">
    <h1 class="tet-title">ブロック落とし</h1>
    <div class="tet-hud">
      <span>スコア: <strong id="tetScore">0</strong></span>
      <span class="tet-plate-info">板の幅: <strong id="tetPlateWidth">10</strong></span>
    </div>
    <div class="tet-main">
      <div class="tet-canvas-wrap">
        <canvas id="tetCanvas" width="160" height="384"></canvas>
      </div>
      <p class="tet-howto">タップでブロックを落とす。放置すると積み上がる。はみ出ると板が縮む</p>
    </div>
  </div>

  <div class="tet-overlay" id="overlay">
    <div class="tet-overlay-box">
      <h2>スタート</h2>
      <p>タップでブロックを落とす。板からはみ出ると板が縮む。乗せられなくなったらゲームオーバー！</p>
      <button type="button" class="btn" id="btnStart">スタート</button>
      <a href="/index.html" class="tet-back">← トップへ戻る</a>
    </div>
  </div>

  <div class="tet-overlay" id="overlayGameOver">
    <div class="tet-overlay-box">
      <h2>ゲームオーバー</h2>
      <p id="gameOverScore">スコア: 0</p>
      <button type="button" class="btn" id="btnRetry">もう一度</button>
      <a href="/index.html" class="tet-back">← トップへ戻る</a>
    </div>
  </div>

  <script src="/assets/header.js"></script>
  <script>
(function () {
  var COLS = 10;
  var ROWS = 30;
  var CELL = 16;
  var FALL_AREA_ROWS = 22;  // 上の考えるスペース（大きい）
  var STACK_VIEW_ROWS = 2;  // 上から2段だけ見える
  var PLATE_MIN = 2;

  var canvas = document.getElementById('tetCanvas');
  var ctx = canvas.getContext('2d');

  // ブロックは横長（1x1, 1x2, 1x3）
  var SHAPES = [
    [[1]],
    [[1,1]],
    [[1,1,1]]
  ];
  var COLORS = ['#00f5ff','#ffd60a','#9d4edd','#06d6a0','#ef476f','#118ab2','#ff9f1c'];

  var grid = [];
  var piece = null;
  var score = 0;
  var state = { running: false, gameOver: false };
  var plateLeft = 0, plateRight = COLS;
  var dropInterval = 900;
  var lastDrop = 0;
  var stackTop = ROWS;

  function initGrid() {
    grid = [];
    for (var r = 0; r < ROWS; r++) {
      grid[r] = [];
      for (var c = 0; c < COLS; c++) grid[r][c] = 0;
    }
    plateLeft = 0;
    plateRight = COLS;
    stackTop = ROWS;
  }

  function randomPiece() {
    var id = Math.floor(Math.random() * SHAPES.length);
    var s = SHAPES[id];
    var mat = [];
    for (var r = 0; r < s.length; r++) {
      mat[r] = s[r].slice();
    }
    return { matrix: mat, color: COLORS[id], id: id };
  }

  function getBlockWidth(p) {
    return p ? p.matrix[0].length : 0;
  }

  function spawn() {
    piece = randomPiece();
    var w = getBlockWidth(piece);
    var maxX = plateRight - w;
    if (maxX <= plateLeft) {
      state.gameOver = true;
      state.running = false;
      document.getElementById('gameOverScore').textContent = 'スコア: ' + score;
      document.getElementById('overlayGameOver').classList.add('visible');
      return;
    }
    piece.x = plateLeft + Math.floor(Math.random() * (maxX - plateLeft));
    piece.y = 0;
  }

  function collides(p, dx, dy) {
    dx = dx || 0; dy = dy || 0;
    var mat = p.matrix;
    for (var r = 0; r < mat.length; r++) {
      for (var c = 0; c < mat[r].length; c++) {
        if (!mat[r][c]) continue;
        var nx = p.x + c + dx, ny = p.y + r + dy;
        if (nx < 0 || nx >= COLS || ny >= ROWS) return true;
        if (ny >= 0 && grid[ny][nx]) return true;
      }
    }
    return false;
  }

  function merge() {
    var mat = piece.matrix;
    var w = getBlockWidth(piece);
    for (var r = 0; r < mat.length; r++) {
      for (var c = 0; c < mat[r].length; c++) {
        if (mat[r][c]) {
          var ny = piece.y + r;
          if (ny >= 0) grid[ny][piece.x + c] = piece.color;
        }
      }
    }
    if (piece.y + mat.length - 1 < stackTop) stackTop = piece.y;

    var overhangL = Math.max(0, plateLeft - piece.x);
    var overhangR = Math.max(0, (piece.x + w) - plateRight);
    if (overhangL > 0) plateLeft = plateLeft + overhangL;
    if (overhangR > 0) plateRight = plateRight - overhangR;

    if (plateRight - plateLeft < PLATE_MIN) {
      state.gameOver = true;
      state.running = false;
      document.getElementById('gameOverScore').textContent = 'スコア: ' + score;
      document.getElementById('overlayGameOver').classList.add('visible');
    }
    document.getElementById('tetPlateWidth').textContent = plateRight - plateLeft;
  }

  function tapDrop() {
    if (!piece || state.gameOver) return;
    while (!collides(piece, 0, 1)) {
      piece.y++;
      score += 1;
    }
    merge();
    spawn();
    document.getElementById('tetScore').textContent = score;
  }

  function tick() {
    if (!state.running || state.gameOver) return;
    var now = Date.now();
    if (now - lastDrop > dropInterval) {
      lastDrop = now;
      if (!collides(piece, 0, 1)) {
        piece.y++;
      } else {
        merge();
        spawn();
      }
      document.getElementById('tetScore').textContent = score;
    }
  }

  function draw() {
    var cw = COLS * CELL;
    var fallAreaH = FALL_AREA_ROWS * CELL;
    var stackAreaH = STACK_VIEW_ROWS * CELL;
    var ch = fallAreaH + stackAreaH;

    ctx.fillStyle = '#0d1b2a';
    ctx.fillRect(0, 0, cw, ch);

    var viewTop = Math.max(0, stackTop - FALL_AREA_ROWS);

    ctx.fillStyle = 'rgba(27, 38, 59, 0.5)';
    ctx.fillRect(0, 0, cw, fallAreaH);
    ctx.fillStyle = '#0d1b2a';
    ctx.fillRect(0, fallAreaH, cw, stackAreaH);

    function rowToY(r) {
      var local = r - viewTop;
      if (local < FALL_AREA_ROWS) return local * CELL;
      return fallAreaH + (local - FALL_AREA_ROWS) * CELL;
    }

    for (var r = viewTop; r < viewTop + FALL_AREA_ROWS + STACK_VIEW_ROWS && r < ROWS; r++) {
      for (var c = 0; c < COLS; c++) {
        if (grid[r][c]) {
          ctx.fillStyle = grid[r][c];
          var y = rowToY(r);
          ctx.fillRect(c * CELL + 1, y + 1, CELL - 2, CELL - 2);
          ctx.strokeStyle = 'rgba(255,255,255,0.2)';
          ctx.lineWidth = 1;
          ctx.strokeRect(c * CELL + 1, y + 1, CELL - 2, CELL - 2);
        }
      }
    }

    if (piece && !state.gameOver) {
      var mat = piece.matrix;
      for (var r = 0; r < mat.length; r++) {
        for (var c = 0; c < mat[r].length; c++) {
          if (mat[r][c]) {
            var gy = piece.y + r;
            if (gy >= viewTop && gy < viewTop + FALL_AREA_ROWS + STACK_VIEW_ROWS) {
              ctx.fillStyle = piece.color;
              var y = rowToY(gy);
              ctx.fillRect((piece.x + c) * CELL + 1, y + 1, CELL - 2, CELL - 2);
              ctx.strokeStyle = 'rgba(255,255,255,0.3)';
              ctx.strokeRect((piece.x + c) * CELL + 1, y + 1, CELL - 2, CELL - 2);
            }
          }
        }
      }
    }

    ctx.fillStyle = 'rgba(65, 90, 119, 0.8)';
    ctx.fillRect(plateLeft * CELL, ch - 4, (plateRight - plateLeft) * CELL, 4);
  }

  function gameLoop() {
    tick();
    draw();
    if (state.running) requestAnimationFrame(gameLoop);
  }

  canvas.addEventListener('click', function (e) {
    e.preventDefault();
    tapDrop();
  });
  canvas.addEventListener('touchstart', function (e) {
    e.preventDefault();
    tapDrop();
  }, { passive: false });

  document.getElementById('btnStart').addEventListener('click', function () {
    document.getElementById('overlay').classList.remove('visible');
    initGrid();
    score = 0;
    state.running = true;
    state.gameOver = false;
    document.getElementById('tetScore').textContent = '0';
    document.getElementById('tetPlateWidth').textContent = COLS;
    spawn();
    lastDrop = Date.now();
    gameLoop();
  });

  document.getElementById('btnRetry').addEventListener('click', function () {
    document.getElementById('overlayGameOver').classList.remove('visible');
    document.getElementById('overlay').classList.remove('visible');
    initGrid();
    score = 0;
    state.running = true;
    state.gameOver = false;
    document.getElementById('tetScore').textContent = '0';
    document.getElementById('tetPlateWidth').textContent = COLS;
    spawn();
    lastDrop = Date.now();
    gameLoop();
  });

  document.getElementById('overlay').classList.add('visible');
  initGrid();
  draw();
})();
  </script>
</body>
</html>
