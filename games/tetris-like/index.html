<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover, user-scalable=no" />
  <title>ブロック落とし – Nihatori Games</title>
  <link rel="stylesheet" href="/styles.css" />
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    html, body { height: 100%; overflow: hidden; touch-action: none; -webkit-tap-highlight-color: transparent; }
    body.game-page {
      padding-top: 48px;
      background: linear-gradient(180deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
      font-family: "MS PGothic", "Yu Gothic", sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
      color: #e8e8e8;
    }
    .tet-wrap {
      flex: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      width: 100%;
      max-width: 520px;
      padding: 8px;
      min-height: 0;
    }
    .tet-title { font-size: 1rem; font-weight: bold; margin-bottom: 4px; flex-shrink: 0; }
    .tet-hud {
      display: flex;
      justify-content: space-between;
      align-items: center;
      width: 100%;
      margin-bottom: 4px;
      font-size: 14px;
      flex-shrink: 0;
    }
    .tet-main {
      display: flex;
      gap: 12px;
      align-items: flex-start;
      justify-content: center;
      flex: 1;
      min-height: 0;
      width: 100%;
    }
    .tet-canvas-wrap {
      flex: 0 0 auto;
      background: #0d1b2a;
      border-radius: 8px;
      overflow: hidden;
      box-shadow: 0 4px 20px rgba(0,0,0,0.5);
      border: 2px solid #415a77;
    }
    #tetCanvas {
      display: block;
      width: 100%;
      height: 100%;
      object-fit: contain;
    }
    .tet-side {
      flex: 0 0 auto;
      display: flex;
      flex-direction: column;
      gap: 8px;
      font-size: 12px;
    }
    .tet-next-wrap {
      background: #0d1b2a;
      border-radius: 8px;
      padding: 8px;
      border: 2px solid #415a77;
    }
    .tet-next-label { margin-bottom: 4px; color: #778da9; }
    #tetNextCanvas { display: block; background: #1b263b; border-radius: 4px; }
    .tet-controls {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      margin-top: 8px;
      justify-content: center;
      align-items: center;
      flex-shrink: 0;
    }
    .tet-btn {
      width: 52px;
      height: 52px;
      border: none;
      border-radius: 10px;
      background: linear-gradient(180deg, #415a77 0%, #1b263b 100%);
      color: #e0e1dd;
      box-shadow: 0 2px 8px rgba(0,0,0,0.3);
      font-size: 18px;
      cursor: pointer;
      -webkit-tap-highlight-color: transparent;
      touch-action: manipulation;
      user-select: none;
      font-weight: bold;
    }
    .tet-btn:active { transform: scale(0.95); }
    .tet-btn.rotate { font-size: 14px; width: 56px; }
    .tet-btn.down { background: linear-gradient(180deg, #e63946 0%, #c1121f 100%); color: #fff; }
    .tet-overlay {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.7);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 20;
      padding: 48px 16px 0;
    }
    .tet-overlay.visible { display: flex; }
    .tet-overlay-box {
      background: linear-gradient(180deg, #1b263b 0%, #0d1b2a 100%);
      border-radius: 16px;
      padding: 24px;
      text-align: center;
      max-width: 320px;
      border: 2px solid #415a77;
      box-shadow: 0 8px 32px rgba(0,0,0,0.5);
      color: #e0e1dd;
    }
    .tet-overlay-box h2 { margin-bottom: 12px; font-size: 1.35rem; color: #e0e1dd; }
    .tet-overlay-box p { margin-bottom: 16px; color: #778da9; font-size: 14px; }
    .tet-overlay-box .btn {
      display: inline-block;
      padding: 12px 28px;
      background: linear-gradient(180deg, #e63946, #c1121f);
      color: #fff;
      border: none;
      border-radius: 10px;
      font-size: 1rem;
      font-weight: bold;
      cursor: pointer;
      text-decoration: none;
      -webkit-tap-highlight-color: transparent;
    }
    .tet-back { display: inline-block; margin-top: 12px; color: #778da9; font-size: 14px; text-decoration: none; }
    .tet-back:hover { text-decoration: underline; color: #e0e1dd; }
    @media (max-width: 400px) {
      .tet-side { display: none; }
    }
  </style>
</head>
<body class="game-page">
  <div id="site-header"></div>

  <div class="tet-wrap">
    <h1 class="tet-title">ブロック落とし</h1>
    <div class="tet-hud">
      <span>スコア: <strong id="tetScore">0</strong></span>
      <span>レベル: <strong id="tetLevel">1</strong></span>
    </div>
    <div class="tet-main">
      <div class="tet-canvas-wrap">
        <canvas id="tetCanvas" width="200" height="400"></canvas>
      </div>
      <div class="tet-side">
        <div class="tet-next-wrap">
          <div class="tet-next-label">NEXT</div>
          <canvas id="tetNextCanvas" width="80" height="80"></canvas>
        </div>
      </div>
    </div>
    <div class="tet-controls">
      <button type="button" class="tet-btn" id="btnLeft">←</button>
      <button type="button" class="tet-btn rotate" id="btnRotate">回転</button>
      <button type="button" class="tet-btn" id="btnRight">→</button>
      <button type="button" class="tet-btn down" id="btnDown">↓</button>
    </div>
  </div>

  <div class="tet-overlay" id="overlay">
    <div class="tet-overlay-box">
      <h2>スタート</h2>
      <p>左右で移動、回転で回転、↓で落下。一列揃うと消えるよ！</p>
      <button type="button" class="btn" id="btnStart">スタート</button>
      <a href="/index.html" class="tet-back">← トップへ戻る</a>
    </div>
  </div>

  <div class="tet-overlay" id="overlayGameOver">
    <div class="tet-overlay-box">
      <h2>ゲームオーバー</h2>
      <p id="gameOverScore">スコア: 0</p>
      <button type="button" class="btn" id="btnRetry">もう一度</button>
      <a href="/index.html" class="tet-back">← トップへ戻る</a>
    </div>
  </div>

  <script src="/assets/header.js"></script>
  <script>
(function () {
  var COLS = 10, ROWS = 20;
  var CELL = 20;
  var canvas = document.getElementById('tetCanvas');
  var nextCanvas = document.getElementById('tetNextCanvas');
  var ctx = canvas.getContext('2d');
  var nextCtx = nextCanvas.getContext('2d');

  var SHAPES = [
    [[1,1,1,1]],
    [[1,1],[1,1]],
    [[0,1,0],[1,1,1]],
    [[0,1,1],[1,1,0]],
    [[1,1,0],[0,1,1]],
    [[1,0,0],[1,1,1]],
    [[0,0,1],[1,1,1]]
  ];
  var COLORS = ['#00f5ff','#ffd60a','#9d4edd','#06d6a0','#ef476f','#118ab2','#ff9f1c'];

  var grid = [];
  var piece = null;
  var nextPiece = null;
  var score = 0, level = 1, lines = 0;
  var state = { running: false, gameOver: false };
  var dropInterval = 1000;
  var lastDrop = 0;

  function initGrid() {
    grid = [];
    for (var r = 0; r < ROWS; r++) {
      grid[r] = [];
      for (var c = 0; c < COLS; c++) grid[r][c] = 0;
    }
  }

  function randomPiece() {
    var id = Math.floor(Math.random() * SHAPES.length);
    var s = SHAPES[id];
    var mat = [];
    for (var r = 0; r < s.length; r++) {
      mat[r] = [];
      for (var c = 0; c < s[r].length; c++) mat[r][c] = s[r][c];
    }
    return { matrix: mat, color: COLORS[id], id: id };
  }

  function spawn() {
    piece = nextPiece || randomPiece();
    nextPiece = randomPiece();
    piece.x = Math.floor((COLS - piece.matrix[0].length) / 2);
    piece.y = 0;
    if (collides(piece)) {
      state.gameOver = true;
      state.running = false;
      document.getElementById('gameOverScore').textContent = 'スコア: ' + score;
      document.getElementById('overlayGameOver').classList.add('visible');
    }
  }

  function collides(p, dx, dy) {
    dx = dx || 0; dy = dy || 0;
    var mat = p.matrix;
    for (var r = 0; r < mat.length; r++) {
      for (var c = 0; c < mat[r].length; c++) {
        if (!mat[r][c]) continue;
        var nx = p.x + c + dx, ny = p.y + r + dy;
        if (nx < 0 || nx >= COLS || ny >= ROWS) return true;
        if (ny >= 0 && grid[ny][nx]) return true;
      }
    }
    return false;
  }

  function merge() {
    var mat = piece.matrix;
    for (var r = 0; r < mat.length; r++) {
      for (var c = 0; c < mat[r].length; c++) {
        if (mat[r][c]) {
          var ny = piece.y + r;
          if (ny >= 0) grid[ny][piece.x + c] = piece.color;
        }
      }
    }
  }

  function clearLines() {
    var cleared = 0;
    var r = ROWS - 1;
    while (r >= 0) {
      var full = true;
      for (var c = 0; c < COLS; c++) if (!grid[r][c]) { full = false; break; }
      if (full) {
        grid.splice(r, 1);
        grid.unshift([]);
        for (var c = 0; c < COLS; c++) grid[0][c] = 0;
        cleared++;
      } else r--;
    }
    if (cleared > 0) {
      var pts = [0, 100, 300, 500, 800];
      score += (pts[cleared] || 800) * level;
      lines += cleared;
      level = Math.floor(lines / 10) + 1;
      dropInterval = Math.max(100, 1000 - (level - 1) * 80);
      document.getElementById('tetScore').textContent = score;
      document.getElementById('tetLevel').textContent = level;
    }
  }

  function rotatePiece() {
    if (!piece || state.gameOver) return;
    var mat = piece.matrix;
    var newMat = [];
    for (var c = 0; c < mat[0].length; c++) {
      newMat[c] = [];
      for (var r = mat.length - 1; r >= 0; r--) newMat[c].push(mat[r][c]);
    }
    var old = piece.matrix;
    piece.matrix = newMat;
    if (collides(piece)) piece.matrix = old;
  }

  function move(dx) {
    if (!piece || state.gameOver) return;
    if (!collides(piece, dx, 0)) piece.x += dx;
  }

  function softDrop() {
    if (!piece || state.gameOver) return;
    if (!collides(piece, 0, 1)) {
      piece.y++;
      score += 1;
      document.getElementById('tetScore').textContent = score;
    } else {
      merge();
      clearLines();
      spawn();
    }
  }

  function tick() {
    if (!state.running || state.gameOver) return;
    var now = Date.now();
    if (now - lastDrop > dropInterval) {
      lastDrop = now;
      if (!collides(piece, 0, 1)) piece.y++;
      else {
        merge();
        clearLines();
        spawn();
      }
    }
  }

  function draw() {
    ctx.fillStyle = '#0d1b2a';
    ctx.fillRect(0, 0, COLS * CELL, ROWS * CELL);

    for (var r = 0; r < ROWS; r++) {
      for (var c = 0; c < COLS; c++) {
        if (grid[r][c]) {
          ctx.fillStyle = grid[r][c];
          ctx.fillRect(c * CELL + 1, r * CELL + 1, CELL - 2, CELL - 2);
          ctx.strokeStyle = 'rgba(255,255,255,0.2)';
          ctx.lineWidth = 1;
          ctx.strokeRect(c * CELL + 1, r * CELL + 1, CELL - 2, CELL - 2);
        }
      }
    }

    if (piece && !state.gameOver) {
      var mat = piece.matrix;
      for (var r = 0; r < mat.length; r++) {
        for (var c = 0; c < mat[r].length; c++) {
          if (mat[r][c]) {
            ctx.fillStyle = piece.color;
            var x = (piece.x + c) * CELL + 1, y = (piece.y + r) * CELL + 1;
            ctx.fillRect(x, y, CELL - 2, CELL - 2);
            ctx.strokeStyle = 'rgba(255,255,255,0.3)';
            ctx.strokeRect(x, y, CELL - 2, CELL - 2);
          }
        }
      }
    }
  }

  function drawNext() {
    nextCtx.fillStyle = '#1b263b';
    nextCtx.fillRect(0, 0, 80, 80);
    if (!nextPiece) return;
    var mat = nextPiece.matrix;
    var cell = 16;
    var ox = (80 - mat[0].length * cell) / 2, oy = (80 - mat.length * cell) / 2;
    for (var r = 0; r < mat.length; r++) {
      for (var c = 0; c < mat[r].length; c++) {
        if (mat[r][c]) {
          nextCtx.fillStyle = nextPiece.color;
          nextCtx.fillRect(ox + c * cell + 1, oy + r * cell + 1, cell - 2, cell - 2);
        }
      }
    }
  }

  function gameLoop() {
    tick();
    draw();
    drawNext();
    if (state.running) requestAnimationFrame(gameLoop);
  }

  var keys = { left: false, right: false, down: false, rotate: false };
  var keyRepeat = { left: 0, right: 0, down: 0 };

  document.addEventListener('keydown', function (e) {
    if (e.key === 'ArrowLeft') { keys.left = true; e.preventDefault(); }
    if (e.key === 'ArrowRight') { keys.right = true; e.preventDefault(); }
    if (e.key === 'ArrowDown') { keys.down = true; e.preventDefault(); }
    if (e.key === 'ArrowUp' || e.key === 'x' || e.key === 'X') { keys.rotate = true; e.preventDefault(); }
    if (e.key === ' ') { e.preventDefault(); if (piece && !state.gameOver) { while (!collides(piece, 0, 1)) { piece.y++; score += 2; } merge(); clearLines(); spawn(); document.getElementById('tetScore').textContent = score; } }
  });
  document.addEventListener('keyup', function (e) {
    if (e.key === 'ArrowLeft') keys.left = false;
    if (e.key === 'ArrowRight') keys.right = false;
    if (e.key === 'ArrowDown') keys.down = false;
    if (e.key === 'ArrowUp' || e.key === 'x' || e.key === 'X') keys.rotate = false;
  });

  setInterval(function () {
    if (!state.running || state.gameOver) return;
    if (keys.left) { keyRepeat.left++; if (keyRepeat.left % 3 === 1) move(-1); }
    else keyRepeat.left = 0;
    if (keys.right) { keyRepeat.right++; if (keyRepeat.right % 3 === 1) move(1); }
    else keyRepeat.right = 0;
    if (keys.down) { keyRepeat.down++; if (keyRepeat.down % 2 === 1) softDrop(); }
    else keyRepeat.down = 0;
    if (keys.rotate) { rotatePiece(); keys.rotate = false; }
  }, 50);

  document.getElementById('btnLeft').addEventListener('mousedown', function () { move(-1); });
  document.getElementById('btnLeft').addEventListener('touchstart', function (e) { e.preventDefault(); move(-1); }, { passive: false });
  document.getElementById('btnRight').addEventListener('mousedown', function () { move(1); });
  document.getElementById('btnRight').addEventListener('touchstart', function (e) { e.preventDefault(); move(1); }, { passive: false });
  document.getElementById('btnRotate').addEventListener('mousedown', function () { rotatePiece(); });
  document.getElementById('btnRotate').addEventListener('touchstart', function (e) { e.preventDefault(); rotatePiece(); }, { passive: false });
  document.getElementById('btnDown').addEventListener('mousedown', function () { softDrop(); });
  document.getElementById('btnDown').addEventListener('touchstart', function (e) { e.preventDefault(); softDrop(); }, { passive: false });

  document.getElementById('btnStart').addEventListener('click', function () {
    document.getElementById('overlay').classList.remove('visible');
    initGrid();
    score = 0; level = 1; lines = 0;
    dropInterval = 1000;
    state.running = true;
    state.gameOver = false;
    document.getElementById('tetScore').textContent = '0';
    document.getElementById('tetLevel').textContent = '1';
    nextPiece = randomPiece();
    spawn();
    lastDrop = Date.now();
    gameLoop();
  });

  document.getElementById('btnRetry').addEventListener('click', function () {
    document.getElementById('overlayGameOver').classList.remove('visible');
    document.getElementById('overlay').classList.remove('visible');
    initGrid();
    score = 0; level = 1; lines = 0;
    dropInterval = 1000;
    state.running = true;
    state.gameOver = false;
    document.getElementById('tetScore').textContent = '0';
    document.getElementById('tetLevel').textContent = '1';
    nextPiece = randomPiece();
    spawn();
    lastDrop = Date.now();
    gameLoop();
  });

  document.getElementById('overlay').classList.add('visible');
  initGrid();
  draw();
  drawNext();
})();
  </script>
</body>
</html>
